#
# Script generated by Katrina Kalantar December, 2017
# Purpose: import the .m8 output for GSNAPL and, for each sequence, identify the least common ancestor.
# Running: python3 python_implementation_phylowalk_m8parse.py -i [input sam file] -o [output file name]
#

import pandas as pd
import argparse
import pymysql
from joblib import Parallel, delayed
import multiprocessing
from collections import Counter
import datetime
import ete3
from ete3 import NCBITaxa

pymysql.install_as_MySQLdb()

### define function to return the date and time at each call
def date():
        return(datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S"))

print(date() + "  BEGINNING SCRIPT")

### create parser object
parser = argparse.ArgumentParser(description = 'Get least common taxonomic ancestor for each read with multiple gsnap .sam alignments')
parser.add_argument('-i','-infile', help='input filepath (gsnapl .m8 file)',type=str)
parser.add_argument('-o','-outfile', help='output filepath',type=str)
parser.add_argument('-ncbi','-ncbi_map', help='this file was generated using alignment to full NCBI database', action='store_true')
parser.add_argument('-t','-taxonwalk', help='apply taxonomic classification and tree walking algorithm', action='store_true')
args = parser.parse_args()

num_cores = multiprocessing.cpu_count()

# initialize the NCBI database
ncbi = NCBITaxa()


### MAIN FUNCTIONALITY ###

# read in .sam file (GSNAPL output) to pandas dataframe, assign to column names
print(date() + "  Begin reading in .sam dataframe")

pre_df = []
f = open(args.i,'r').readlines()

for l in f:                          # loop through all lines in the .sam file
    if not ( l[0] == '@' ):                 # make sure it is not a header line
        clean_line = l.strip().split('\t')          # split the line into individual fields

        # if the .sam line was unmapped, ignore it - don't want "*" values when extracting GI values in the next set of steps
        if clean_line[2] == "*":
            print("Ignoring unmapped sequence: " + ' '.join(clean_line))
        else:
            cl = clean_line[0:11] + ['_'.join(clean_line[11:-1])] # collapse all extra flags into a single element (so that all rows are same length)
            pre_df.append(cl)

df = pd.DataFrame(pre_df, columns = ['qname','flag','rname','pos','mapq','cigar','rnext','pnext','tlen','seq','qual','additional_flags']) # convert list of lists to DF

print(date() + '  Finished reading in .m8 dataframe')

# get the GI number that each row mapped to
if(args.ncbi):  # .sam was generated against NCBI database, aka GI values are wrapped in this format: "gi|XXXX|gb|XXX"
    sseqid_list = list(df['rname'])
    gi_values = [i.split('|')[1] for i in sseqid_list]  # extract GI from NCBI format
    df['raw_gi'] = gi_values  # append the raw GI values to dataframe for future reference
else:
    gi_values =   list(df['rname'])
    df['raw_gi'] = gi_values  # append the raw GI values to dataframe for future reference

# get the associated tax_id values from the MySQL DB mapping GI -> TaxID
tax_id_vals = []
unknown_taxids = []
gi_values_set = list(set(gi_values))

if args.t:  # if user specifies to perform taxonomy walking - do all taxonomy walking functionality (core script)

    ### set up MySQL connections ###
    # connect to NCBITaxonomy DB to get gi to taxid mappings
    mysql_cn = pymysql.connect(host='localhost',
            port=3306,user='mysql_user', passwd='balamuthia',
            db='NCBI_Taxonomy')



    print(date() + "  GI Values Set (# of GIs to loop through to get tax_id values): " + str(len(gi_values_set)))
    for j in gi_values_set:
        try:
            a = pd.read_sql('select tax_id from gi_to_taxid where gi = ' + j + ';',con=mysql_cn)['tax_id'][0]
            tax_id_vals.append(str(a))
        except: # No TaxID was found for this GI
            unknown_taxids.append(j)  # save the GIs for which no TaxID could be found
            tax_id_vals.append(None)  # set taxID to 'None' for these cases, will be ignored in downstream analysis

    # write the GI values without an associated TaxID to an output .report file (for investigative purposes)
    thefile = open(args.o+".report", 'w')
    for item in list(set(unknown_taxids)):
        thefile.write("%s\n" %item)

    taxid_to_gi_map = pd.Series(dict(zip(gi_values_set,tax_id_vals)))
    taxid_to_gi_map.rename("tax_id")


    # append the TaxID values to the dataframe using matrix join operation
    df2 = df.join(taxid_to_gi_map.to_frame(), on='raw_gi', how='left')
    cols = list(df2.columns)
    cols[-1]='tax_id'
    df2.columns = cols

    query_seqs = list(df2.groupby('qname')['tax_id'].apply(set).index)  # unique list of query sequences, despite multiple alignments
    print(query_seqs[0:5])
    print(date() + "  Gathered query sequences")
    sets = df2.groupby('qname')['tax_id'].apply(set)  # create the set of taxIDs for each query seq ID
    print(date() + "  Iterating through set of taxIDs")
    set_of_taxids = [ ','.join([str(j) for j in list(i)]) for i in sets]  # create comma-separated list of taxIDs -> this becomes a new unique value


    qseqid_to_set_map = pd.Series(dict(zip(query_seqs, set_of_taxids)))   # map query sequences to the unique list of taxIDs
    print(date() + "  Generated sets of tax IDs")
    set_of_sets = list(set(set_of_taxids))  #  create a set from lists of taxIDs (to minimize redundancy in calling taxonomy walking function)


    # hard-coded variable indicating the class to rank values
    rank_series = pd.Series({'species':1,'genus':2,'family':3,'order':4,'class':5,'phylum':6,'kingdom':7,'superkingdom':8,'no rank':9})

    print(date() + "  Set of Sets (# of tax_id sets to loop through to get common ancestors): " + str(len(set_of_sets)))


    ### CORE ALGORITHM FOR TAXONOMY WALKING ###

    ## COULD PARALLELIZE THIS BY SPLITTING SET_OF_SETS UP AND RUNNING A SUBSET
    ## OF THAT VARIABLE THROUGH THIS FUNCTION ON EACH THREAD
    # note: actually ran into DB problems in quick test of this. dev of parallel code on pause.

    # loop through all sets of taxIDs to identify the common ancestor (taxID, level, and name)
    common_ancestors_list = []
    common_ancestors_levels = []
    common_ancestors_names = []
    for i in set_of_sets:
            a = i.split(',')
            if 'None' in a:
                    a.remove('None')  # ignore all "None" values (failure to find TaxID from associated GI)

            if len(a) > 1:  # there is more than 1 taxID, must find LCA

                    lineage_list = []
                    for j in a:
                            try:
                                    lineage_list.append(ncbi.get_lineage(j))
                            except:
                                    print('tax id invalid: ' + str(j))

                    # create DF with lineage taxID and # of times it occurred.
                    counts = pd.Series(Counter(sum(lineage_list,[])))
                    # LCA will be present in every lineage, so LCA have count = len(lineage_list)
                    common_ancestors = pd.Series(ncbi.get_rank(list(counts[counts == len(lineage_list)].index)))
                    # reverse the order of the dataframe keys/values
                    common_ancestors_swap = pd.Series(dict((v,k) for k,v in common_ancestors.iteritems()))
                    # create dataframe for easy manipulation
                    result_df = pd.DataFrame(data=dict(s1=common_ancestors_swap, s2=rank_series))
                    result_df.dropna(inplace=True)

                    # debugging 01/10/18
                    try:
                        # the LCA is the value with the smallest rank out of all taxIDs with count = len(lineage_list)
                        CA = str(int(result_df[result_df['s2'] == min(result_df['s2'])]['s1'][0]))
                        level = str(result_df[result_df['s2'] == min(result_df['s2'])].index[0])
                    except:
                        print(result_df)
                        CA = 1
                        level = None

                    common_ancestors_list.append(CA)
                    common_ancestors_levels.append(level)
                    print(ncbi.get_taxid_translator([int(CA)]))
                    common_ancestors_names.append(ncbi.get_taxid_translator([int(CA)])[int(CA)])

            elif len(a) == 1:  # only 1 taxID mapped, so it is the LCA by default

                    common_ancestors_list.append(a[0])
                    ranks_swap = pd.Series(dict((v,k) for k,v in pd.Series(ncbi.get_rank(a[0])).iteritems()))
                    result_df = pd.DataFrame(data=dict(s1=ranks_swap, s2=rank_series))
                    level = str(result_df[result_df['s2'] == min(result_df['s2'])].index[0])
                    common_ancestors_levels.append(level)

                    try:
                        common_ancestors_names.append(ncbi.get_taxid_translator([int(a[0])])[int(a[0])])
                    except: # added this to avoid the error shown below
                        common_ancestors_names.append("NA")

                    #Traceback (most recent call last):
                    #File "../scripts/python_implementation_phylowalk_m8parse.py", line 131, in <module>
                    #common_ancestors_names.append(ncbi.get_taxid_translator([int(a[0])])[int(a[0])])
                    #KeyError: 0
            else:  # the only GI that mapped did not have a TaxID
                    common_ancestors_list.append(None)
                    common_ancestors_levels.append(None)
                    common_ancestors_names.append(None)

    print(date() + "  Completed LCA tracing for all sets")

    ### Preparing taxonomy-walking results for output ###

    # convert lists to dictionaries so that we can create a dataframe
    set_to_ancestor_map = dict(zip(set_of_sets,common_ancestors_list))
    set_to_ancestor_class_map = dict(zip(set_of_sets,common_ancestors_levels))
    set_to_ancestor_name_map = dict(zip(set_of_sets,common_ancestors_names))

    # create new sub-DataFrame with taxonomy info, to be joined with original .m8 DataFrame
    set_master_map = pd.DataFrame(data=dict(LCA=set_to_ancestor_map, LCAclass=set_to_ancestor_class_map, LCAname=set_to_ancestor_name_map))

    print(date() + "  Generating final dataframes")

    df3 = df2.join(qseqid_to_set_map.to_frame(), on='qname',how='left')
    df3.columns = (list(df2.columns) + ['taxid_list'])
    df4 = df3.join(set_master_map, on=['taxid_list'],how='left')


else: # user did not specify taxonomy walking, but multiple GI mappings appended to the appropriate line
    df4=df # DID NOT compute the extra additions to the dataframe that would be computed in taxon walking, so need to reference original dataframe
    query_seqs = list(df4.groupby('qname')['raw_gi'].apply(set).index)  # unique list of query sequences, despite multiple alignments

print(date() + "  Iterating through set of GIs")
gi_sets = df4.groupby('qname')['raw_gi'].apply(set)  # create set of GIs for each query seq ID #rname
set_of_gis = [','.join([str(j) for j in list(i)]) for i in gi_sets]  # create comma-separated list of GIs -> this becomes a new unique value
qseqid_to_giset_map = pd.Series(dict(zip(query_seqs, set_of_gis)))   # map query sequences to the unique list of GIs


df5 = df4.join(qseqid_to_giset_map.to_frame(), on='qname',how='left')
df5.columns = (list(df4.columns) + ['GIlist'])

print(date() + "  Writing to output file")
df5.to_csv(args.o,index=False,sep="\t")
print(date() + "  COMPLETED")



# The output has the following columns:
# qname   - query sequence ID, matches the .fasta sequence header
# flag - sam alignment bitwise flag
# rname - reference sequence ID
# pos - position in reference sequence where the read mapped
# mapq - mapping quality
# cigar - CIGAR string
# rnext - location of mapping for next read
# pnext - position of the next read
# tlen - fragment length (relevant pairwise alignments)
# seq - sequence
# qual - sequence quality
# additional_flags - all additional sam format flags (aligner-specific), merged into one field with "_" characters
# raw_gi - the raw gi value
# *tax_id - the taxid to which the GI maps to
# *taxid_list - the list of all taxIDs for GIs that this read mapped to
# *LCA - TaxID of the LCA
# *LCAclass - the class corresponding to the TxID of LCA (ie genus, phylum, kingdom)
# *LCAname - the human-readable name associated with the TaxID of LCA
# GIlist - the list of all gi values that this read mapped to

# * only returned when run in -t mode, with access to NCBI database
